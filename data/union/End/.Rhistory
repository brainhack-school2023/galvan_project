i<-1
h<-4
f.hat<-c()
for(i in 1:length(datos$sl2l_dm))
{
f.hat[i]<-f_sombrero(datos$sl2l_dm[i],epa,datos=datos$sl2l_dm[-i],h)
}
# para un h fijo, el segundo termino de LSCV(h)
2*mean(f.hat)
# ventana con LSCV (leave-one-out-Cross-Validation)
lscv<-function(datos,k, h)
{
f.hat.x<-c()
for(i in 1:length(datos))
{
f.hat.x[i]<-f_sombrero(datos[i],k,datos[-i],h)
}
LSCV<-integrate(Vectorize(f_sombrero,"x"),lower=-Inf,upper=Inf,k=k,datos=datos,h=h)$value-2*mean(f.hat.x)
return(LSCV)
}
h<-seq(10,28,1) # si la ventana es muy chiquita se queja...se queja por todo el integrate...
LSCV_h<-c()
for(j in 1:length(h))
{
LSCV_h[j]<-lscv(datos$sl2l_dm,epa,h[j])
}
plot(h,LSCV_h,type="l") #pasa que para muchas ventanas no encontró datos...no las tengo en cuenta
plot(h[2:6],LSCV_h[2:6],type = "l")
h[which.max(LSCV_h)]
# Estimadores basados en nucleos
# Estimacion Parzen
uniforme<-function(u)
{
ifelse(u>-1 & u<1,1,0)/2  # es mi indicadora y mi calcula el nucleo uniforme
}
#para nucleos
f_sombrero<-function(x,k,datos,h) #datos= Xi
{
s<-0
for(i in 1:length(datos))
{
c<-k((x-datos[i])/h)
s<-s+c
}
f<-s/(length(datos)*h)
return(f)
}
# Otros nucleos
epa<-function(u)
{
ifelse(abs(u) < 1,3/4*(1-u^2),0)
}
densidad.est.parzen<-function(x,h,z) # x: datos, z:valor donde exaluo la f
{
f_sombrero(z,uniforme,x,h)
}
#ventana de CV (Convalidaci´on Cruzada por M´axima Verosimilitud)
# primero veamos como funciona el calculo del segundo termino
i<-1
h<-3
f.hat<-c()
for(i in 1:length(datos$sl2l_dm))
{
f.hat[i]<-f_sombrero(datos$sl2l_dm[i],epa,datos=datos$sl2l_dm[-i],h)
}
# para un h fijo, el segundo termino de LSCV(h)
2*mean(f.hat)
# ventana con LSCV (leave-one-out-Cross-Validation)
lscv<-function(datos,k, h)
{
f.hat.x<-c()
for(i in 1:length(datos))
{
f.hat.x[i]<-f_sombrero(datos[i],k,datos[-i],h)
}
LSCV<-integrate(Vectorize(f_sombrero,"x"),lower=-Inf,upper=Inf,k=k,datos=datos,h=h)$value-2*mean(f.hat.x)
return(LSCV)
}
h<-seq(10,28,1) # si la ventana es muy chiquita se queja...se queja por todo el integrate...
LSCV_h<-c()
for(j in 1:length(h))
{
LSCV_h[j]<-lscv(datos$sl2l_dm,epa,h[j])
}
plot(h,LSCV_h,type="l") #pasa que para muchas ventanas no encontró datos...no las tengo en cuenta
plot(h[2:6],LSCV_h[2:6],type = "l")
h[which.max(LSCV_h)]
source("D:/2022/UBA/IntroEstCsDatos/Practicas/ejemplo.R", echo=TRUE)
# Ahora uso las formulas construidas en el ejercicio teorico para conseguir las estimaciones puntuales basadas en la muestra
est_mom<-4*mean(data$sl2l_diameter)
n1<-sum(data$sl2l_diameter<0)
n2<-sum(data$sl2l_diameter>0)
est_mv<-(n2-n1)/length(data$sl2l_diameter)
data$sl2l_diameter[1]
data$sl2l_diameter[2]
for(i in 1:Nrep)
{
u<-data$sl2l_diameter[i]
x<-ifelse(u<0.45,u/0.9-0.5,(u-0.45)/1.1) # aca me "invente"mis n muestras de x
emo[i]<-4*mean(x)
emv[i]<-(sum(x>0)-sum(x<0))/n
}
Nrep<-length(data$sl2l_diameter)
emo<-c()
emv<-c()
for(i in 1:Nrep)
{
u<-data$sl2l_diameter[i]
x<-ifelse(u<0.45,u/0.9-0.5,(u-0.45)/1.1) # aca me "invente"mis n muestras de x
emo[i]<-4*mean(x)
emv[i]<-(sum(x>0)-sum(x<0))/n
}
for(i in 1:Nrep)
{
u<-data$sl2l_diameter[i]
x<-ifelse(u<0.45,u/0.9-0.5,(u-0.45)/1.1) # aca me "invente"mis n muestras de x
emo[i]<-4*mean(x)
emv[i]<-(sum(x>0)-sum(x<0))/Nrep
}
par(mfrow=c(1,2))
hist(emo,freq=FALSE, col = col1)
hist(emo,freq=FALSE)
hist(emv,freq=FALSE)
abline(h=tita,col=col3, lwd=3,lty=2)
par(mfrow=c(1,1))
plot(emo,pch=20,col=col1)
plot(emo,pch=20)
points(emv,pch=20)
abline(h=tita, lwd=3,lty=2)
par(mfrow=c(1,2))
hist(emo,freq=FALSE)
library(ggplot2)
library(gridExtra)
sum(sample(urna,3)=="V")
help("sample")
urna<-c(rep("R",3),rep("V",4),rep("A",3))
n<-1000
set.seed(27)
xy<-matrix(0,nrow = n,ncol = 2)
for(i in 1:n)
{
muestra<-sample(urna,3)
xy[i,]<-c(sum(muestra=="V"),sum(muestra=="R"))
}
plot(xy[,1],xy[,2],pch=20, col="darkblue")
M<-table(xy[,1],xy[,2])/n
M
#grafico del soporte en el que puedo ver los pesos (interesante...)
datos<-as.data.frame(M)
pp<-ggplot(datos, aes(Var1,Var2))+
geom_point(aes(size=Freq))+
labs(title="Función de probabilidad conjunta",
y = "y", x= "x")
pp
# ¿como calculo lo que quiero? vectores logicos...
y<-xy[,2]
x<-xy[,1]
fi_sombrero0<-sum(y[x==0])/length(x[x==0])
abline(h=mean(y), col="darkolivegreen")
y0<-mean(xy[xy[,1]==0,2])
y1<-mean(xy[xy[,1]==1,2])
y2<-mean(xy[xy[,1]==2,2])
y3<-mean(xy[xy[,1]==3,2])
ey<-c(y0,y1,y2,y3)
plot(xy[,1],xy[,2],pch=20, col="darkblue",xlab="x",ylab="y")
points(0:3,ey,pch=20,col="chocolate")
lines(0:3,ey,pch=20,col="chocolate",lwd=1.5)
datos<-read.table("lidar.txt",header = TRUE)
#1
help("ksmooth")
plot(datos$range,datos$int.conc,pch=20,col="skyblue",
xlab= "Ratio", ylab = "Logaritmo del cociente")
# Nadaraya watson usando R, si no te armas la funcion
regNP<-ksmooth(datos$range,datos$int.conc,kernel = "normal", bandwidth = 5,
x.points = datos$range)
lines(regNP$x,regNP$y,col= "chocolate",lwd=2)
regNP2<-ksmooth(datos$range,datos$int.conc,kernel = "normal", bandwidth = 10,
x.points = datos$range)
lines(regNP2$x,regNP2$y,col= "darkred",lwd=2)
regNP3<-ksmooth(datos$range,datos$int.conc,kernel = "normal", bandwidth = 30,
x.points = datos$range)
lines(regNP3$x,regNP3$y,col= "forestgreen",lwd=2)
regNP4<-ksmooth(datos$range,datos$int.conc,kernel = "normal", bandwidth = 50,
x.points = datos$range)
lines(regNP4$x,regNP4$y,col= "red",lwd=2)
ecpp1<-mean((datos$int.conc-regNP$y)^2)
ecpp2<-mean((datos$int.conc-regNP2$y)^2)
help(crb)
install.packages("BSSasymp")
library('BSSasymp')
help(crb)
help(CRB)
f1<-function(x)
{
gamma(5)*(1+(x*sqrt(9/7))^2/9)^(-5)/
(sqrt(9*pi/(9/7))*gamma(9/2))
}
f2<-function(x)
{
exp(-(x)^2/2)/sqrt(2*pi)
}
CRB(sdf=c(f1,f2))
CRB(sdf=f1)
CRB(sdf=c(f1))
CRB(sdf=c(f2))
CRB(sdf=c(f1, f2))
help(bootdist)
```{r}
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rnorm(n,19,1.05)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rnorm(n,19,1.05)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#muestra parametros de la ultima muestra generada
musombrero[n]
sigmasombrero[n]
lines(0:500/10,dnorm(0:500/10,musombrero[n],sigmasombrero[n],col="red")
lines(0:500/10,dnorm(0:500/10,musombrero[n],sigmasombrero[n]),col="red")
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rnorm(n,19,1.05)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#muestra parametros de la ultima muestra generada
musombrero[n]
sigmasombrero[n]
lines(0:500/10,dnorm(0:500/10,musombrero[n],sigmasombrero[n]),col="red")
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rlogis(n,19,1.05)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#muestra parametros de la ultima muestra generada
musombrero[n]
sigmasombrero[n]
lines(0:500/10,dlogis(0:500/10,musombrero[n],sigmasombrero[n]),col="red")
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rlogis(n,19,1.05)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#muestra parametros de la ultima muestra generada
musombrero[n]
sigmasombrero[n]
lines(0:1000/10,dlogis(0:1000/10,musombrero[n],sigmasombrero[n]),col="red")
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rlogis(n,19,1.05)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#muestra parametros de la ultima muestra generada
musombrero[n]
sigmasombrero[n]
lines(0:500/10,dlogis(0:500/10,musombrero[n],sigmasombrero[n]),col="red")
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rlogis(n,19,1.05)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#muestra parametros de la ultima muestra generada
musombrero[n]
sigmasombrero[n]
lines(0:500/10,dlogis(0:500/10,musombrero[n],sigmasombrero[n]),col="red")
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rlogis(n,19,1.05)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#muestra parametros de la ultima muestra generada
musombrero[n]
sigmasombrero[n]
lines(0:500/10,dlogis(0:500/10,musombrero[n],sigmasombrero[n]),col="red")
library(ggplot2)
library(gridExtra)
library(MASS)
library(fitdistrplus)
library(ggstatsplot)
help("bootdist")
library(ggstatsplot)
library(ggplot2)
library(gridExtra)
library(MASS)
library(fitdistrplus)
library(ggstatsplot)
### Ubicacion de datos
setwd("C:/hcgalvan/Repositorios/hcgalvan_project/data/union/End")
temp = gsub(".*target.*", "", readLines("seleccionestudio.csv"))
data<-read.table(text=temp, sep=",", header=TRUE)
sl2ldm <-data$sl2l_diameter
fitlog<-fitdist(sl2ldm,"logis")
View(fitlog)
summary(fitlog)
plot(fitlog)
plot(fitlog, demp=TRUE)
plot(fitg, histo = FALSE, demp = TRUE)
plot(fitlog, histo = FALSE, demp = TRUE)
cdfcomp(fitlog, addlegend=FALSE)
denscomp(fitlog, addlegend=FALSE)
ppcomp(fitlog, addlegend=FALSE)
qqcomp(fitlog, addlegend=FALSE)
fitlogmme <- fitdist(sl2ldm, “logis”, method=”mme”)
fitlogmme <- fitdist(sl2ldm, "logis", method="mme")
summary(fitlogmme)
plot(fitlogmme, demp=T)
gofstat(list(fitlog, fitlogmme), fitnames=c(“Logis mle”, “logis mme”))
gofstat(list(fitlog, fitlogmme), fitnames=c("Logis mle", "logis mme"))
View(fitlogmme)
alpha=23.19;beta=0.24
u<-runif(100000,0,1)
x<-alpha-beta*log((1-u)/u)
hist(x,prob=T,main="",ylab="f(x)",ylim=c(0,0.016),col="grey")
y<-function(x){
exp(-(x-alpha)/beta)/(beta*( 1+exp(-(x-alpha)/beta))^2)
}
par(new=T)
curve(y,-50,250,main="",axes=FALSE,lwd=2,ylab="")
box()
text(180,0.01,expression(paste(alpha==23.19)))
text(180,0.009,expression(paste(beta==.24)))
#23.19, 0.24
alpha=100;beta=15
u<-runif(100000,0,1)
x<-alpha-beta*log((1-u)/u)
hist(x,prob=T,main="",ylab="f(x)",ylim=c(0,0.016),col="grey")
y<-function(x){
exp(-(x-alpha)/beta)/(beta*( 1+exp(-(x-alpha)/beta))^2)
}
par(new=T)
curve(y,-50,250,main="",axes=FALSE,lwd=2,ylab="")
box()
text(180,0.01,expression(paste(alpha==23.19)))
text(180,0.009,expression(paste(beta==.24)))
# El método de la transformada inversa se utiliza para simular variables aleatorias continuas, mediante la función de distribución acumulada y la generación de números aleatorios con distribución uniforme en el intervalo (0,1).
# funcion logística
#23.19, 0.24
alpha=30;beta=15
u<-runif(100000,0,1)
x<-alpha-beta*log((1-u)/u)
hist(x,prob=T,main="",ylab="f(x)",ylim=c(0,0.016),col="grey")
y<-function(x){
exp(-(x-alpha)/beta)/(beta*( 1+exp(-(x-alpha)/beta))^2)
}
par(new=T)
curve(y,-50,250,main="",axes=FALSE,lwd=2,ylab="")
box()
text(180,0.01,expression(paste(alpha==23.19)))
text(180,0.009,expression(paste(beta==.24)))
# El método de la transformada inversa se utiliza para simular variables aleatorias continuas, mediante la función de distribución acumulada y la generación de números aleatorios con distribución uniforme en el intervalo (0,1).
# funcion logística
#23.19, 0.24
alpha=30;beta=15
u<-runif(100000,0,1)
x<-alpha-beta*log((1-u)/u)
hist(x,prob=T,main="",ylab="f(x)",ylim=c(0,0.016),col="grey")
y<-function(x){
exp(-(x-alpha)/beta)/(beta*( 1+exp(-(x-alpha)/beta))^2)
}
par(new=T)
curve(y,-50,250,main="",axes=FALSE,lwd=2,ylab="")
box()
text(180,0.01,expression(paste(alpha==30)))
text(180,0.009,expression(paste(beta==15)))
# Genera muestras aleatorias que siguen una distribución normal de parametros mu=... y sigma=..
# Para cada muestra almacena los momentos 1 y 2 en los vectores anteriores.
n = 1000
mediax=rep(0,n)
mediaxcuadrado=rep(0,n)
for (i in 1:n){
x=rlogis(n,23.19,0.24)
mediax[i]=mean(x)
mediaxcuadrado[i]=mean(x^2)
}
#Calcula los parámetros (mu y sigma) a partir de las muestras
musombrero = mediax
sigmasombrero = sqrt(mediaxcuadrado-mediax^2)
hist(x,probability = TRUE)
#muestra parametros de la ultima muestra generada
musombrero[n]
sigmasombrero[n]
lines(0:500/10,dlogis(0:500/10,musombrero[n],sigmasombrero[n]),col="red")
# El método de la transformada inversa se utiliza para simular variables aleatorias continuas, mediante la función de distribución acumulada y la generación de números aleatorios con distribución uniforme en el intervalo (0,1).
# funcion logística
#23.19, 0.24
alpha=30;beta=15
u<-runif(100000,23.19,0.24)
x<-alpha-beta*log((1-u)/u)
hist(x,prob=T,main="",ylab="f(x)",ylim=c(0,0.016),col="grey")
# El método de la transformada inversa se utiliza para simular variables aleatorias continuas, mediante la función de distribución acumulada y la generación de números aleatorios con distribución uniforme en el intervalo (0,1).
# funcion logística
#23.19, 0.24
alpha=30;beta=15
u<-runif(100000,0,1)
x<-alpha-beta*log((1-u)/u)
hist(x,prob=T,main="",ylab="f(x)",ylim=c(0,0.016),col="grey")
y<-function(x){
exp(-(x-alpha)/beta)/(beta*( 1+exp(-(x-alpha)/beta))^2)
}
par(new=T)
curve(y,-50,250,main="",axes=FALSE,lwd=2,ylab="")
box()
text(180,0.01,expression(paste(alpha==30)))
text(180,0.009,expression(paste(beta==15)))
f1<-function(x)
{
gamma(5)*(1+(x*sqrt(9/7))^2/9)^(-5)/
(sqrt(9*pi/(9/7))*gamma(9/2))
}
f2<-function(x)
{
exp(-(x)^2/2)/sqrt(2*pi)
}
CRB(sdf=c(f1,f2))
library(ggplot2)
library(gridExtra)
library(MASS)
library(fitdistrplus)
library(ggstatsplot)
library(BSSasymp) #Cramer-ca
f1<-function(x)
{
gamma(5)*(1+(x*sqrt(9/7))^2/9)^(-5)/
(sqrt(9*pi/(9/7))*gamma(9/2))
}
f2<-function(x)
{
exp(-(x)^2/2)/sqrt(2*pi)
}
CRB(sdf=c(f1,f2))
CRB(sdf=c(f1, f2))
install.packages("nprobust")
libray(nprobust)
install.packages("rtools")
